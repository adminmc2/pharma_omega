<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Puro Omega - Orb Logo</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      min-height: 100vh;
      /* Fondo pastel clarito - mezcla de Clinical White y Soft Blue */
      background: #E8EEF8;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-family: 'Quicksand', sans-serif;
    }
    #orb-container {
      width: 200px;
      height: 200px;
      border-radius: 50%;
      overflow: hidden;
    }
    canvas {
      display: block;
    }
    h1 {
      margin-top: 24px;
      color: #101B2C;
      font-weight: 700;
      font-size: 2rem;
    }
    p {
      color: #36454F;
      margin-top: 8px;
    }
  </style>
  <link href="https://fonts.googleapis.com/css2?family=Quicksand:wght@500;700&display=swap" rel="stylesheet">
</head>
<body>
  <div id="orb-container"></div>
  <h1>Puro Omega</h1>
  <p>Asistente de ventas con IA</p>

  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  <script>
    /* ============================================
       PURO OMEGA - Orb con colores corporativos
       ============================================
       Tech Cyan:        #31BEEF → rgb(0.19, 0.75, 0.94)
       Soft Blue:        #A1B8F2 → rgb(0.63, 0.72, 0.95)
       Visionary Violet: #994E95 → rgb(0.60, 0.31, 0.58)
       Prisma Navy:      #101B2C → rgb(0.06, 0.11, 0.17)
    */

    let scene, camera, renderer, orbCore, orbGlow, clock = new THREE.Clock();
    const container = document.getElementById('orb-container');

    init();
    animate();

    function init() {
      scene = new THREE.Scene();

      const size = Math.min(container.clientWidth, container.clientHeight);
      camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
      camera.position.z = 2.5;

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(size, size);
      renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
      renderer.setClearColor(0x000000, 0);
      container.appendChild(renderer.domElement);

      const geometry = new THREE.SphereGeometry(1, 128, 128);

      // Core orb - Colores Puro Omega
      const coreMat = new THREE.ShaderMaterial({
        uniforms: {
          uTime:  { value: 0 },
          uScale: { value: 1 }
        },
        vertexShader: `
          uniform float uTime, uScale;
          varying vec3 vPos;
          varying vec3 vNormal;
          void main() {
            vPos = position;
            vNormal = normal;
            float wave = sin(position.x*5. + uTime*2.)*0.015
                       + sin(position.y*6. + uTime*2.5)*0.015
                       + sin(position.z*7. + uTime*1.8)*0.015;
            vec3 pos = position * (1.0 + wave * uScale);
            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos,1.);
          }
        `,
        fragmentShader: `
          uniform float uTime;
          varying vec3 vPos;
          varying vec3 vNormal;

          void main() {
            // Colores Puro Omega
            vec3 techCyan = vec3(0.19, 0.75, 0.94);      // #31BEEF
            vec3 softBlue = vec3(0.63, 0.72, 0.95);      // #A1B8F2
            vec3 violet = vec3(0.60, 0.31, 0.58);        // #994E95

            // Gradiente animado
            float t1 = sin(vPos.x*2. + uTime*1.5) * 0.5 + 0.5;
            float t2 = sin(vPos.y*3. + uTime*1.2) * 0.5 + 0.5;

            vec3 color1 = mix(techCyan, softBlue, t1);
            vec3 color = mix(color1, violet, t2 * 0.3);

            // Fresnel para profundidad
            float fresnel = pow(1.0 - abs(dot(normalize(vNormal), vec3(0,0,1))), 1.5);
            color = mix(color, techCyan, fresnel * 0.4);

            gl_FragColor = vec4(color, 1.0);
          }
        `,
        transparent: false
      });
      orbCore = new THREE.Mesh(geometry, coreMat);
      orbCore.scale.set(0.8, 0.8, 0.8);
      scene.add(orbCore);

      // Glow layer - Tech Cyan glow
      const glowMat = new THREE.ShaderMaterial({
        uniforms: {
          uTime:      { value: 0 },
          uScale:     { value: 1 },
          uIntensity: { value: 1.0 }
        },
        vertexShader: coreMat.vertexShader,
        fragmentShader: `
          uniform float uTime, uIntensity;
          varying vec3 vPos;
          varying vec3 vNormal;

          void main() {
            float rim = pow(1.0 - abs(dot(normalize(vNormal), vec3(0,0,1))), 2.0);

            // Glow en Tech Cyan
            vec3 glowColor = vec3(0.19, 0.75, 0.94); // #31BEEF
            vec3 glow = glowColor * rim * uIntensity;

            gl_FragColor = vec4(glow, rim * 0.5);
          }
        `,
        blending: THREE.AdditiveBlending,
        transparent: true,
        depthWrite: false
      });
      orbGlow = new THREE.Mesh(geometry, glowMat);
      orbGlow.scale.set(0.88, 0.88, 0.88);
      scene.add(orbGlow);

      // Luz suave
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);

      const pointLight = new THREE.PointLight(0x31BEEF, 0.8);
      pointLight.position.set(2, 2, 3);
      scene.add(pointLight);

      window.addEventListener('resize', onResize);
    }

    function onResize() {
      const size = Math.min(container.clientWidth, container.clientHeight);
      renderer.setSize(size, size);
    }

    function animate() {
      requestAnimationFrame(animate);
      const t = clock.getElapsedTime();

      // Animacion suave de "respiracion"
      const breathe = Math.sin(t * 2) * 0.08 + 0.92;
      const subtle = Math.sin(t * 4) * 0.02;
      const activity = breathe + subtle;

      orbCore.material.uniforms.uTime.value = t;
      orbGlow.material.uniforms.uTime.value = t;
      orbCore.material.uniforms.uScale.value = activity;
      orbGlow.material.uniforms.uScale.value = activity;
      orbGlow.material.uniforms.uIntensity.value = activity * 1.1;

      // Rotacion lenta
      orbCore.rotation.y = orbGlow.rotation.y = t * 0.15;
      orbCore.rotation.x = orbGlow.rotation.x = Math.sin(t * 0.5) * 0.1;

      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
